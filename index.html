<!-- TODO
Reakcja na najazd mysza
Reakcja na klikniecie mysza
Dodanie pozostalych planet
Ksiezyce (ruch mozliwie najdokladniej fizycznie)
Skalowanie rozmiarow i odleglosci (na podstawie fizycznych realiów)
Reset pozycji kamery +-+

IMPORTANT Obsługa aktualizacji aplikacji i pauzy animacji po zasterowaniu czasem
-->



<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Interaktywny Układ Słoneczny</title>
		<link href="style.css" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" type="image/x-icon" href="icons/favicon.png">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" 
        integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" 
        crossorigin="anonymous">
	</head>
	<body>
		<div class="show" id="settingspanel" >
			<div id="settingsbtn" onclick="togglesettingsbar()"></div>
			<div class="dateinfo" id="infodate"></div>
                <div class="row">
                    <ul>
                        <li><a class="settings_button" onclick="minusyear()"><img src="icons/my.png" alt="-Y"></i></a></li>
                        <li><a class="settings_button" onclick="minusmonth()"><img src="icons/mm.png" alt="-M"></a></i></li>
                        <li><a class="settings_button" onclick="minusday()"><img src="icons/minus.png" alt="+"></a></li>
                        <li><a id="pp" class="settings_button playpause" onclick='toggleanimation();'><img id="ppbtn" src="icons/play.png" alt=""></img></a></li>
                        <li><a class="settings_button" onclick="plusday(); removealltrails();"><img src="icons/plus.png" alt="+"></a></li>
                        <li><a class="settings_button" onclick="plusmonth()"><img src="icons/pm.png" alt="+M"></a></i></li>
                        <li><a class="settings_button" onclick="plusyear()"><img src="icons/py.png" alt="+Y"></a></i></li>
                    </ul>
                </div>
                <div class="row">
                    <p class="podajdate">Podaj datę:</p><input type="date" id="data" class="datepickerfield" placeholder="Wybierz Datę">
					<a class="settings_button sd" onclick="ustawczas()">Potwierdź datę</a>
					<div class="slidecontainer">
						<p>Skala rozmiaru planet:</p>
						<a class="realscale" id="realpscale" onclick="setrealscale()">Realna</a>
						<a class="resetskali" id="scalereset" onclick="scalereset()">Reset</a>
						<input type="range" min="0.5" max="5" value="1" step="0.1" class="slider" id="psizerange">
						<div id="rangeval"></div>
					</div>
					<div class="labelsvisibility">
						Pokaż/ukryj nazwy planet: <input type="checkbox" id="labelview" name="" checked onclick="labelview()">
					</div>
					<div class="orbitconfigcontainer">
						<div class="allorbitcheck">
							Pokaż/ukryj wszystkie orbity: 
							<input type="checkbox" id="orbitview" checked onclick="orbitview()"></div>
							lub tylko wybrane:
						<div class="specifiedorbitchecks">
							<div><p>M</p><input type="checkbox" name="" id="" checked onclick="toggletrail(mtr)"></div>
							<div><p>W</p><input type="checkbox" name="" id="" checked onclick="toggletrail(vtr)"></div>
							<div><p>Z</p><input type="checkbox" name="" id="" checked onclick="toggletrail(etr)"></div>
							<div><p>M</p><input type="checkbox" name="" id="" checked onclick="toggletrail(matr)"></div>
							<div><p>J</p><input type="checkbox" name="" id="" checked onclick="toggletrail(jtr)"></div>
							<div><p>S</p><input type="checkbox" name="" id="" checked onclick="toggletrail(str)"></div>
							<div><p>U</p><input type="checkbox" name="" id="" checked onclick="toggletrail(utr)"></div>
							<div><p>N</p><input type="checkbox" name="" id="" checked onclick="toggletrail(ntr)"></div>
						</div>
				</div>
				<div class="row">
				</div>
                <div class="timestatus">
                    <div class="tstat"></div>
                    <input type="checkbox" id="play" checked>
                </div>
			</div>
		</div>
		<div id="info">
			Symulator eksploracji układu słonecznego - v16<br>
			Upływ czasu: <p id="timespeed"></p> dni / sekundę
		</div>

		<!-- INFORMACJE O PLANECIE -->
		<div id="planetinfopanel">
			<div id="tinfop" onclick="hideasidebar();"><div id="asidebtn"></div></div>
			<div id="pname">Nazwa</div>
			<div id="plive">
				<div id="canvas"></div>
			</div>
			<div id="pdescription">Opis</div>
		</div>

		</div>
		<div class="resetcamera">
			<a id="cameraresetbtn" 
			onclick="cameratween(camToSave.position, camToSave.rotation, camToSave.controlCenter)">
			RESET KAMERY
			</a>
		</div>
		<p class="pcdesc">Porównanie realnych wielkości planet:</p>
		<div class="planetscomparison">
			<div class="planetsizecntainer">
				<div class="slabel">Słońce</div>
				<div class="planet" id="sun"></div>
			</div>
			<div class="planetsizecontainer">
				<div class="plabel">Merkury</div>
				<div class="hitbox" id="mercuryhitbox" onclick="showasidebar();toggleinfobar(mercury)">
					<div class="planet" id="mercury"></div>
				</div>
			</div>
			<div class="planetsizecontainer">
				<div class="plabel">Wenus</div>
				<div class="hitbox" id="venushitbox" onclick="showasidebar();toggleinfobar(venus)">
					<div class="planet" id="venus"></div>
				</div>
			</div>
			<div class="planetsizecontainer">
					<div class="plabel">Ziemia</div>
				<div class="hitbox" id="earthhitbox" onclick="showasidebar();toggleinfobar(earth)">
					<div class="planet" id="earth"></div>
				</div>
			</div>
			<div class="planetsizecontainer">
					<div class="plabel">Mars</div>
				<div class="hitbox" id="marshitbox" onclick="showasidebar();toggleinfobar(mars)">
					<div class="planet" id="mars"></div>
				</div>
			</div>
			<div class="planetsizecontainer">
					<div class="plabel">Jowisz</div>
					<div class="hitbox" id="jupiterhitbox" onclick="showasidebar();toggleinfobar(jupiter)">
				<div class="planet" id="jupiter"></div></div>
			</div>
			<div class="planetsizecontainer">
					<div class="plabel">Saturn</div>
					<div class="hitbox" id="saturnhitbox" onclick="showasidebar();toggleinfobar(saturn)">
				<div class="planet" id="saturn"></div></div>
			</div>
			<div class="planetsizecontainer">
					<div class="plabel">Uran</div>
					<div class="hitbox" id="uranushitbox" onclick="showasidebar();toggleinfobar(uranus)">
				<div class="planet" id="uranus"></div></div>
			</div>
			<div class="planetsizecontainer">
					<div class="plabel">Neptun</div>
					<div class="hitbox" id="neptunehitbox" onclick="showasidebar();toggleinfobar(neptune)">
				<div class="planet" id="neptune"></div></div>
			</div>
		</div>
		<script src="js/three.js"></script>
		<script src="datesettings.js"></script> <!--funkcje zmiany czasu-->
		<script src="positionscounting.js"></script><!--obliczanie pozycji planet-->
		<script src="gui.js"></script><!--interakcje z interface-->
		<script src="js/Projector.js"></script>
		<script src="js/Tween.js"></script>
		<script src="js/Orbitcontrols.js"></script>
		<script src="//unpkg.com/three-spritetext"></script>
		<script>
			// deaktywuje animacje gdy karta przegladarki nie jest aktywna
			let tabfocus = true;
			window.onfocus = () => {
				tabfocus = true;
				// console.log("Focus!");
			}
			window.onblur = () => {
				tabfocus = false;
				// console.log("Blur!");
			}

			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// DEKLARACJE ZMIENNYCH (dla czystości kodu)
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			
			// zmienne do wyliczania pozycji planet
			let mercurydata = 
			{id: 1, ows: 365*0.25, ink: 7.00507,an: 48.3339,ph: 77.454,md: 0.3870978,dm: 4.092353,eksorb: 0.2056324,ml: 314.42369, axistilt: 0};
			let venusdata = 
			{id: 2, ows: 365*0.7, ink: 3.39472,an: 76.6889,ph: 131.761,md: 0.7233238,dm: 1.602158,eksorb: 0.0067933,ml: 236.94045, axistilt: 177.3};
			let earthdata = 
			{id: 3, ows: 365, ink: 0,an: 349.2,ph: 102.8517,md: 1,dm: 0.9855796,eksorb: 0.0166967,ml: 328.40353, axistilt: 23.44};
			let marsdata = 
			{id: 4, ows: 365*2, ink: 1.84992,an: 49.5664,ph: 336.0882,md: 1.5236365,dm: 0.5240613,eksorb: 0.0934231,ml: 262.42784, axistilt: 25.2};
			let jupiterdata = 
			{id: 5, ows: 365*12, ink: 1.30463,an: 100.4713,ph: 15.6978,md: 5.202597,dm: 0.08309618,eksorb: 0.0484646,ml: 322.55983, axistilt: 3.1};
			let saturndata = 
			{id: 6, ows: 365*30, ink: 2.48524,an: 113.6358,ph: 88.863,md: 9.5719,dm: 0.03328656,eksorb: 0.0531651,ml: 20.95759, axistilt: 26.7};
			let uranusdata = 
			{id: 7, ows: 365*165, ink: 0.77343,an: 74.0954,ph: 175.6807,md: 19.30181,dm: 0.01162295,eksorb: 0.0428959,ml: 303.18967, axistilt: 97.8};
			let neptunedata = 
			{id: 8, ows: 365*249, ink: 1.7681,an: 131.7925,ph: 7.206,md: 30.26664,dm: 0.005919282,eksorb: 0.0102981,ml: 299.8641, axistilt: 28.3};


			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// INICJALIZACJA SCENY I WSTĘPNA KONFIGURACJA ORBITCONTROLS ITD
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

			// WSTĘPNE USTAWIENIE CZASU
			// ustawianie domyslnie dzisiejszej daty w datepicker
			let delay = 200;
			let date = new Date();	
			let b2 = date.getFullYear(); //year
			let b3 = date.getMonth()+1; //month
			let b4 = date.getDate(); //day
			let b5 = date.getHours(); //hours
			let b6 = date.getMinutes(); //minutes
			let strdate = b4+" " +miesiace[b3-1]+" "+b2+" r";
			document.getElementById("infodate").innerHTML = "Data: "+strdate;
			window.setInterval( function() {
				if (document.hidden == false) {
					if (animationstate == true) {
						b2 = date.getFullYear(); //year
						b3 = date.getMonth()+1; //month
						b4 = date.getDate(); //day
						b5 = date.getHours(); //hours
						b6 = date.getMinutes(); //minutes
						date.setDate(date.getDate()+1);
						strdate = b4+" " +miesiace[b3-1]+" "+b2+" r";
						document.getElementById("infodate").innerHTML = "Data: "+strdate;
					}
				}
			}, delay);

			// utworzenie sceny i kamery, rozmiar uniwersum
			let unisize = 1500; //rozmiar uniwersum

			let scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2( 0x111111, 0.0005 );
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 1, unisize*2 );
			let camera2 = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 1, unisize*2 );

			let projector = new THREE.Projector();
			addEventListener( 'mousemove', onMouseMove, false );

			// konfiguracja biblioteki OrbitControls.js
			let controls = new THREE.OrbitControls( camera );
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 0.4;
			controls.panSpeed = 0.5; 
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [ 65, 83, 68 ];
			// controls.addEventListener( 'change', animate );

			// window resize
			window.addEventListener( 'resize', onWindowResize, false );
			function onWindowResize(){
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			// wstęp do obsługi ruchy myszy
			let mfc = {x: 0, y: 0};
			let mouse = { x: 0, y: 0 }, INTERSECTED;
			function onMouseMove( event ) 
				{
					mfc.x = event.clientX;
					mfc.y = event.clientY;
					if ((mfc.x <= settingspanel.offsetWidth) && (mfc.y <= settingspanel.offsetHeight)){
						controls.enabled = false;
						// console.log("x: "+mfc.x+" y: "+mfc.y);
					} else controls.enabled = true;
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y =  -( event.clientY / window.innerHeight ) * 2 + 1;
				}
			
			// silnik renderujący obraz
			let renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			renderer.shadowMap.enabled = true;
			renderer.setClearColor( 0x000006, 1 );

			// główna kamera
			container = document.getElementById( 'canvas' );
			document.getElementById("plive").appendChild( container );

			// dodatkowa kamera
			renderer2 = new THREE.WebGLRenderer();
			renderer2.setSize( 320, 180 );
			container.appendChild( renderer2.domElement );


			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//  				IMPLEMENTACJA FUNKCJI TWEEN
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

				const tweenobject = (mesh, target, multiplier) => {
					let initial = mesh.position;
					let targetpos = {x:0,y:0,z:0};
					// console.log(targetpos);
					targetpos.x = target[0]*multiplier;
					targetpos.z = target[1]*multiplier;
					targetpos.y = target[2]*globaldistanceaspect;
					let tween = new TWEEN.Tween(initial).to(targetpos, delay);
					tween.onUpdate(function(){
						mesh.position.x = initial.x;
						mesh.position.y = initial.y;
						mesh.position.z = initial.z;
					});
					tween.start();
				}

				const cameratween = (position, rotation, controlCenter) => {
					let initialpos = camera.position;
					let targetpos = {x: position.x, y: position.y, z: position.z};
					// console.log("Init: "+initialpos.x+" target: "+targetpos.x);
					let initialrot = camera.rotation;
					let targetrot = {x: rotation.x, y: rotation.y, z: rotation.z};
					controls.center.set(controlCenter.x, controlCenter.y, controlCenter.z);
					// controls.update();
					console.log("Camera movement!");
					let tweenpos = new TWEEN.Tween(initialpos).to(targetpos,1000).easing(TWEEN.Easing.Cubic.InOut);
					tweenpos.onUpdate(function() {
						camera.position.x = initialpos.x;
						camera.position.y = initialpos.y;
						camera.position.z = initialpos.z;
						// camera.lookAt(sun.position);
					});
					let tweenrot = new TWEEN.Tween(initialrot).to(targetrot,1000).easing(TWEEN.Easing.Cubic.InOut);
					tweenrot.onUpdate(function() {
						camera.rotation.x = initialrot.x;
						camera.rotation.y = initialrot.y;
						camera.rotation.z = initialrot.z;
						// camera.lookAt(sun.position);
					});
					// camera.rotation.set(rotation.x, rotation.y, rotation.z);
					tweenpos.start();
					tweenrot.start();
					// togglecambtn();
					console.log("Movement end!");
				}

			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

			
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// DODAWANIE OBIEKTÓW DO SCENY

			//#region

			// rozmiar ziemii
			let sizemultiplier = 5;
			let globaldistanceaspect = 200;
			let planetlabelsize = 20;

			//universe
			let unigeo = new THREE.SphereGeometry(unisize, 50, 50);
			let unitexture = new THREE.TextureLoader().load('textures/universe.jpg');
			let unimat = new THREE.MeshBasicMaterial({color: 0xffffff, map: unitexture});
			let universe = new THREE.Mesh(unigeo, unimat);
			universe.material.side = THREE.BackSide;
			scene.add(universe);

			//gwiazdy
			let stargeo = new THREE.SphereGeometry( 0.3, 9, 9);
			let starmat =  new THREE.MeshPhongMaterial( { color:0xFFFFFF} );
			for ( let i = 0; i < 300; i ++ ) {
					let mesh = new THREE.Mesh( stargeo, starmat );
					mesh.position.x = ( Math.random() - 0.5 ) * unisize;
					mesh.position.y = ( Math.random() - 0.5 ) * unisize;
					mesh.position.z = ( Math.random() - 0.5 ) * unisize;
					mesh.updateMatrix();
					mesh.castShadow = false;
					mesh.receiveShadow = false;
					mesh.matrixAutoUpdate = false;
					scene.add( mesh );
				}

			// namelabels
			let namelabels = [];


			//slonce + swiatlo
			let sungeo = new THREE.SphereGeometry( 75, 100, 100 );
			let sun = new THREE.PointLight( 0xFFFFFF, 1, 0, 2 );
			let suntexture = new THREE.TextureLoader().load('textures/sunmap.jpg');
			let sunmaterial = new THREE.MeshBasicMaterial( { color: 0xFFFFFF, map: suntexture} );
			sun.add( new THREE.Mesh( sungeo, sunmaterial ) );
			sun.castShadow = false;
			sun.receiveShadow = false;
			sun.name = 0;
			scene.add( sun );
			sun.position.set(0,0,0);

			//label z nazwa
			let sunlabel = new SpriteText('Słońce');
			sunlabel.fontFace = 'sans-serif';
			sunlabel.textHeight = planetlabelsize * 1.618;
			// sunlabel.scale.set(35,12,1);
			sunlabel.position.set(0,100,0);
			namelabels.push(sunlabel);
			scene.add(sunlabel);
	
			let ambientlight = new THREE.AmbientLight( 0xFFFFFF, 0.6 );
			scene.add(ambientlight);
		
			// merkury
			let mercgeo = new THREE.SphereGeometry(1,50,50);
			let mercurytexture = new THREE.TextureLoader().load('textures/mercurymap.jpg');
			let mercurymat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: mercurytexture} );
			let mercury = new THREE.Mesh(mercgeo,mercurymat);
			let meinitscale = 9;
			mercury.receiveShadow = false;
			mercury.castShadow = false;
			mercury.name = 1;
			scene.add(mercury);
			mercury.scale.set(meinitscale,meinitscale,meinitscale);
			//label z nazwa
			let mercurylabel = new SpriteText(PLnames[0]);
			mercurylabel.fontFace = 'sans-serif';
			mercurylabel.textHeight = planetlabelsize;
			namelabels.push(mercurylabel);
			scene.add(mercurylabel);

			//venus
			let veng = new THREE.SphereGeometry(1,50,50);
			let venustexture = new THREE.TextureLoader().load('textures/venusmap.jpg');
			let venusmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: venustexture} );
			let venus = new THREE.Mesh(veng,venusmat);
			let veinitscale = 11;
			venus.receiveShadow = false;
			venus.castShadow = false;
			venus.name = 2;
			scene.add(venus);
			venus.scale.set(veinitscale,veinitscale,veinitscale);
			//label z nazwa
			let venuslabel = new SpriteText(PLnames[1]);
			venuslabel.fontFace = 'sans-serif';
			venuslabel.textHeight = planetlabelsize;
			namelabels.push(venuslabel);
			scene.add(venuslabel);

			//ziemia + ksiezyc
			let earthg = new THREE.SphereGeometry(1,50,50);
			let earthtexture = new THREE.TextureLoader().load('textures/earthmap1k.jpg');
			let earthm = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: earthtexture } );	
			let earth = new THREE.Mesh(earthg,earthm);
			let eainitscale = 12;
			earth.receiveShadow = false;
			earth.castShadow = false;
			earth.name = 3;
			scene.add(earth);
			earth.scale.set(eainitscale,eainitscale,eainitscale);
			//label z nazwa
			let earthlabel = new SpriteText(PLnames[2]);
			earthlabel.fontFace = 'sans-serif';
			earthlabel.textHeight = planetlabelsize;
			namelabels.push(earthlabel);
			scene.add(earthlabel);
			//earthglow
			let eaglowmat = new THREE.MeshLambertMaterial({ color: 0x99DDff, transparent: true, opacity: 0.4});
			let eaglowpivot = new THREE.Object3D();
			earth.add(eaglowpivot);
			let eaglow = new THREE.Mesh (earthg, eaglowmat);
			eaglow.scale.set(1.1,1.1,1.1);
			eaglowpivot.add(eaglow);
			// księżyc
			let earthPivot = new THREE.Object3D();
			earth.add( earthPivot );
			let moontexture = new THREE.TextureLoader().load('textures/moonmap.jpg');
			let moonmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: moontexture } );
			let moon = new THREE.Mesh( earthg, moonmat );
			moon.position.x = 3;
			moon.scale.set(0.25, 0.25, 0.25);
			moon.receiveShadow = true;
			earthPivot.add( moon );

			//mars
			let marsg = new THREE.SphereGeometry(1,50,50);
			let marstexture = new THREE.TextureLoader().load('textures/marsmap.jpg');
			let marsmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: marstexture } );
			let mars = new THREE.Mesh(marsg,marsmat);
			let mainitscale = 10;
			mars.receiveShadow = false;
			mars.castShadow = false;
			mars.name = 4;
			scene.add(mars);
			mars.scale.set(mainitscale,mainitscale,mainitscale);
			//label z nazwa
			let marslabel = new SpriteText(PLnames[3]);
			marslabel.fontFace = 'sans-serif';
			marslabel.textHeight = planetlabelsize;
			namelabels.push(marslabel);
			scene.add(marslabel);

			//jowisz
			let jupiterg = new THREE.SphereGeometry(1,50,50);
			let jupitertexture = new THREE.TextureLoader().load('textures/jupitermap.jpg');
			let jupitermat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: jupitertexture } );
			let jupiter = new THREE.Mesh(jupiterg,jupitermat);
			let juinitscale = 25;
			jupiter.receiveShadow = false;
			jupiter.castShadow = false;
			jupiter.name = 5;
			scene.add(jupiter);
			jupiter.scale.set(juinitscale,juinitscale,juinitscale);
			//label z nazwa
			let jupiterlabel = new SpriteText(PLnames[4]);
			jupiterlabel.fontFace = 'sans-serif';
			jupiterlabel.textHeight = planetlabelsize;
			namelabels.push(jupiterlabel);
			scene.add(jupiterlabel);

			//saturn
			let saturng = new THREE.SphereGeometry(1,50,50);
			let saturntexture = new THREE.TextureLoader().load('textures/saturnmap.jpg');
			let saturnmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: saturntexture } );
			let saturn = new THREE.Mesh(saturng,saturnmat);
			let sainitscale = 22;
			saturn.receiveShadow = false;
			saturn.castShadow = false;
			saturn.name = 6;
			scene.add(saturn);
			saturn.scale.set(sainitscale,sainitscale,sainitscale);
			// pierscienie
			// let saturnringgeo = new THREE.RingGeometry( 1.2, 2.2, 30, 30, 0, Math.PI * 2 );
			let saturnringtexture = new THREE.TextureLoader().load('textures/saturnringcolor.jpg');
			let saturnringmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: saturnringtexture } );
			let saturnPivot = new THREE.Object3D();
			saturn.add( saturnPivot );
			saturnPivot.rotation.x = 80;
			for ( let i = 0; i < 200; i ++ ) {
				let mesh = new THREE.Mesh( stargeo, saturnringmat );
				mesh.scale.set(0.1 , 0.1, 0.1);
				let radius = (Math.random()-0.5)*1.2+ 1.8;
                let randomZ = (Math.random()-0.5)*0.2;
				mesh.position.x = (Math.cos(i))*radius;
				mesh.position.y = (Math.sin(i))*radius;
				mesh.position.z = randomZ;
				mesh.castShadow = false;
				mesh.receiveShadow = false;
				mesh.updateMatrix();
				mesh.matrixAutoUpdate = false;
			saturnPivot.add( mesh );
			}
			//label z nazwa
			let saturnlabel = new SpriteText(PLnames[5]);
			saturnlabel.fontFace = 'sans-serif';
			saturnlabel.textHeight = planetlabelsize;
			namelabels.push(saturnlabel);
			scene.add(saturnlabel);

			//uran
			let uranusg = new THREE.SphereGeometry(1,50,50);
			let uranustexture = new THREE.TextureLoader().load('textures/uranusmap.jpg');
			let uranusmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: uranustexture } );
			let uranus = new THREE.Mesh(uranusg,uranusmat);
			let urinitscale = 20;
			uranus.receiveShadow = false;
			uranus.castShadow = false;
			uranus.name = 7;
			scene.add(uranus);
			uranus.scale.set(urinitscale,urinitscale,urinitscale);
			// pierscienie
			// let uranusringgeo = new THREE.RingGeometry( 1.2, 2.2, 30, 30, 0, Math.PI * 2 );
			let uranusringtexture = new THREE.TextureLoader().load('textures/uranusringcolour.jpg');
			let uranusringmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: saturnringtexture } );
			let uranusPivot = new THREE.Object3D();
			// uranus.add( uranusPivot );
			uranusPivot.rotation.x = 80;
			for ( let i = 0; i < 100; i ++ ) {
				let mesh = new THREE.Mesh( stargeo, uranusringmat );
				mesh.scale.set(0.1 , 0.1, 0.1);
				let radius = (Math.random()-0.5)*0.3+1.8;
                let randomZ = (Math.random()-0.5)*0.1;
				mesh.position.x = (Math.cos(i))*radius;
				mesh.position.y = (Math.sin(i))*radius;
				mesh.position.z = randomZ;
				mesh.castShadow = false;
				mesh.receiveShadow = false;
				mesh.updateMatrix();
				mesh.matrixAutoUpdate = false;
			// uranusPivot.add( mesh );
			}
			// label z nazwa
			let uranuslabel = new SpriteText(PLnames[6]);
			uranuslabel.fontFace = 'sans-serif';
			uranuslabel.textHeight = planetlabelsize;
			namelabels.push(uranuslabel);
			scene.add(uranuslabel);

			//neptun
			let neptuneg = new THREE.SphereGeometry(1,50,50);
			let neptunetexture = new THREE.TextureLoader().load('textures/neptunemap.jpg');
			let neptunemat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: neptunetexture } );
			let neptune = new THREE.Mesh(neptuneg,neptunemat);
			let neinitscale = 18;
			neptune.receiveShadow = false;
			neptune.castShadow = false;
			neptune.name = 5;
			scene.add(neptune);
			neptune.scale.set(neinitscale,neinitscale,neinitscale);
			//label z nazwa
			let neptunelabel = new SpriteText(PLnames[7]);
			neptunelabel.fontFace = 'sans-serif';
			neptunelabel.textHeight = planetlabelsize;
			namelabels.push(neptunelabel);
			scene.add(neptunelabel);


			// pas asteroid
			let asteroidbelt = new THREE.Object3D();
			sun.add(asteroidbelt);
			let astrogeo = new THREE.SphereGeometry (.85, 4, 4);
			let astromat = new THREE.MeshPhongMaterial ({color: 0xffffff} );
			for ( let i = 0; i < 1000; i ++ ) {
				let mesh = new THREE.Mesh( astrogeo, astromat );
				let radius = (Math.random()-0.5)*80+520;
                let randomY = (Math.random()-0.5)*30;
				let posx = Math.cos(i)*radius;
				mesh.position.x = (Math.cos(i))*radius;
				mesh.position.z = (Math.sin(i))*radius;
				mesh.position.y = randomY;
				mesh.castShadow = false;
				mesh.receiveShadow = false;
				mesh.updateMatrix();
				mesh.matrixAutoUpdate = false;
				asteroidbelt.add(mesh);
			}
			
			let tracegeometry = new THREE.Geometry();
			let tracematerial = new THREE.LineBasicMaterial({color: 0xFFFFFF});
			let etracemat = new THREE.LineBasicMaterial({color: 0x27aa53});

			//#endregion
		
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// WSTEPNE USTAWIENIA KAMERY I ZAPISANIE POZYCJI DO JAKIEJ MA WRACAĆ
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			camera.position.set(-300,1000,550);
			campos = camera.position;
			camera.lookAt (new THREE.Vector3(sun.position.x, sun.position.y, sun.position.z));

			let camToSave = {};
			camToSave.position = camera.position.clone();
			camToSave.rotation = camera.rotation.clone();
			camToSave.controlCenter = controls.center.clone();
			scene.rotation.x = 0.02;
			const resetcameraposition = (position, rotation, controlCenter) => {
					camera.position.set(parseInt(position.x), position.y, position.z);
					camera.rotation.set(rotation.x, rotation.y, rotation.z);
					controls.center.set(controlCenter.x, controlCenter.y, controlCenter.z);
					controls.update();
					togglecambtn();
					render();
				}
			
			camera2.position.set(50,50,50);
			camera2.lookAt(sun.position);

			
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// ORBITY - TRACES
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

			// rysowanie orbit za planetami (dla 1 planety)
			// let trails_add_length = 30;
			// dane wyjsciowe dla rysunków orbit
			// updateplanetspositions();
			mercury.initpos = mercury.position;
			venus.initpos = venus.position;
			earth.initpos = earth.position;
			mars.initpos = mars.position;
			jupiter.initpos = jupiter.position;
			saturn.initpos = saturn.position;
			uranus.initpos = uranus.position;
			neptune.initpos = neptune.position;

			// merkury orbita
			let mtg = new THREE.Geometry();
			for (let i=0; i < parseInt(mercurydata.ows); i++){
				mtg.vertices.push(new THREE.Vector3(mercury.position));
			}
			let mtr = new THREE.Line(mtg, tracematerial);
			mtr.geometry.dynamic = true;
			scene.add(mtr);

			//venus orbita
			let vtg = new THREE.Geometry();
			for (let i=0; i < parseInt(venusdata.ows) ; i++){vtg.vertices.push(new THREE.Vector3(venus.position)); }
			let vtr = new THREE.Line(vtg, tracematerial); vtr.geometry.dynamic = true; scene.add(vtr);

			//ziemia orbita
			let etg = new THREE.Geometry();
			for (let i=0; i < parseInt(earthdata.ows) + 50 ; i++){
				etg.vertices.push(new THREE.Vector3(earth.position));
			}
			let etr = new THREE.Line(etg, etracemat);
			etr.geometry.dynamic = true;
			scene.add(etr);

			//mars orbita
			let matg = new THREE.Geometry();
			for (let i=0; i < parseInt(marsdata.ows) + 50 ; i++){
				matg.vertices.push(new THREE.Vector3(mars.position));
			}
			let matr = new THREE.Line(matg, tracematerial);
			matr.geometry.dynamic = true;
			scene.add(matr);

			//jowisz orbita jupiter
			let jtg = new THREE.Geometry();
			for (let i=0; i < parseInt(jupiterdata.ows) + 50 ; i++){
				jtg.vertices.push(new THREE.Vector3(jupiter.position));
			}
			let jtr = new THREE.Line(jtg, tracematerial);
			jtr.geometry.dynamic = true;
			scene.add(jtr);

			// saturn orbita
			let stg = new THREE.Geometry();
			for (let i=0; i < parseInt(saturndata.ows) + 50 ; i++){
				stg.vertices.push(new THREE.Vector3(saturn.position));
			}
			let str = new THREE.Line(stg, tracematerial);
			str.geometry.dynamic = true;
			scene.add(str);

			// uran orbita
			let utg = new THREE.Geometry();
			for (let i=0; i < parseInt(uranusdata.ows) + 50 ; i++){
				utg.vertices.push(new THREE.Vector3(uranus.position));
			}
			let utr = new THREE.Line(utg, tracematerial);
			utr.geometry.dynamic = true;
			scene.add(utr);

			// neptun orbita
			let ntg = new THREE.Geometry();
			for (let i=0; i < parseInt(neptunedata.ows) + 50 ; i++){
				ntg.vertices.push(new THREE.Vector3(neptune.position));
			}
			let ntr = new THREE.Line(ntg, tracematerial);
			ntr.geometry.dynamic = true;
			scene.add(ntr);



			// dodaje punkt orbity
			const addtrail = (planet,x,y,z,planettrace) => {
				// shift the array
				planettrace.geometry.vertices.push(planettrace.geometry.vertices.shift());
				// add the point to the end of the array
				planettrace.geometry.vertices[parseInt(planet.ows)-1] = new THREE.Vector3(x,y,z);
				planettrace.geometry.verticesNeedUpdate = true;
			}

			// usuwanie rysowanych orbit
			const removetrail = (trail, planet, mesh) => {
				for (let i=0; i < parseInt(planet.ows)+30; i++) {
				trail.vertices[i] = (new THREE.Vector3(mesh.position));
				}
			}
			const removealltrails = () => {
				removetrail(mtg, mercurydata, mercury);
				removetrail(vtg, venusdata, venus);
				removetrail(etg, earthdata, earth);
				removetrail(matg, marsdata, mars);
				removetrail(jtg, jupiterdata, jupiter);
				removetrail(stg, saturndata, saturn);
				removetrail(utg, uranusdata, uranus);
				removetrail(ntg, neptunedata, neptune)
			;}

			const showtrail = (planet_trail) => {planet_trail.visible = true;}
			const hidetrail = (planet_trail) => {planet_trail.visible = false;}

			const toggletrail = (planet_trail) => {
				if(planet_trail.visible == true) hidetrail(planet_trail);
				else showtrail(planet_trail);
			}
			const togglealltrails = () => {toggletrail(mtr);toggletrail(vtr);toggletrail(etr);toggletrail(matr);toggletrail(jtr);toggletrail(str);toggletrail(utr);toggletrail(ntr);}
			const showalltrails = () => {showtrail(mtr);showtrail(vtr);showtrail(etr);showtrail(matr);showtrail(jtr);showtrail(str);showtrail(utr);showtrail(ntr);}
			const hidealltrails = () => {hidetrail(mtr);hidetrail(vtr);hidetrail(etr);hidetrail(matr);hidetrail(jtr);hidetrail(str);hidetrail(utr);hidetrail(ntr);}

				
			

			// INIT
			var init = function () {
				requestAnimationFrame ( animate);
				let b2 = date.getFullYear(); //year
				let b3 = date.getMonth()+1; //month
				let b4 = date.getDate(); //day
				let b5 = date.getHours(); //hours
				let b6 = date.getMinutes(); //minutes
				updateplanetspositions(b2,b3,b4,b5,b6);


				//NACHYLENIA PLANET:
				mercury.rotation.x = -(mercurydata.axistilt * Math.PI/180);
				venus.rotation.x = -(venusdata.axistilt * Math.PI/180);
				earth.rotation.x = -(earthdata.axistilt * Math.PI/180);
				mars.rotation.x = -(marsdata.axistilt * Math.PI/180);
				jupiter.rotation.x = -(jupiterdata.axistilt * Math.PI/180);
				saturn.rotation.x = -(saturndata.axistilt * Math.PI/180);
				uranus.rotation.x = -(uranusdata.axistilt * Math.PI/180);
				neptune.rotation.x = -(neptunedata.axistilt * Math.PI/180);
			}

			// ANIMATE
			let i = 0;
			let j = 0;
			var animate = function () {
			TWEEN.update();
			updatelabelspositions();

				// czestotliwosc odswiezania symulacji ( 40 FPS )
				setTimeout( function() {
			        requestAnimationFrame( animate );
			    }, 1000/40);

				//wciągnięcie szczegółów daty
				let b2 = date.getFullYear(); //year
				let b3 = date.getMonth()+1; //month
				let b4 = date.getDate(); //day
				let b5 = date.getHours(); //hours
				let b6 = date.getMinutes(); //minutes
				

				//CAŁY MOVEMENT
				if(animationstate == true) {

				//ustawienie planet po przeliczeniu ich pozycji (co 8 klatek)
				if(++i % 8 == 0) {
					console.log("TIK, j: "+j);
					++j;
					updateplanetspositions(b2,b3,b4,b5,b6);	
						switch (j) {
							case 1:
								addtrail(mercurydata, mercury.position.x, mercury.position.y, mercury.position.z, mtr);
							break;
							case 2:
								addtrail(venusdata, venus.position.x, venus.position.y, venus.position.z, vtr);
							break;
							case 3:
								addtrail(earthdata, earth.position.x, earth.position.y, earth.position.z, etr);
							break;
							case 4:
								addtrail(marsdata, mars.position.x, mars.position.y, mars.position.z, matr);
							break;
							case 5:
								addtrail(jupiterdata, jupiter.position.x, jupiter.position.y, jupiter.position.z, jtr);
								addtrail(mercurydata, mercury.position.x, mercury.position.y, mercury.position.z, mtr);
							break;
							case 6:
								addtrail(saturndata, saturn.position.x, saturn.position.y, saturn.position.z, str);
							break;
							case 7:
								addtrail(uranusdata, uranus.position.x, uranus.position.y, uranus.position.z, utr);
							break;
							case 8:
								addtrail(neptunedata, neptune.position.x, neptune.position.y, neptune.position.z, ntr);
								j = 0;
							break;
							default:
							break;
						}
					i = 0;
					document.getElementById("timespeed").innerText = 1000/delay;
				}	
				// console.log(i);
				
				
				// pojawienie sie przycisku jesli ruszymy kamera
				setTimeout(function() {
					if ((parseInt(camera.position.y) < 145) || (parseInt(camera.position.y) > 155)) {
						camreset.style.opacity = 1;
					} else camreset.style.opacity = 0;
					if (animationstate == true) {
						document.getElementById("ppbtn").src = "icons/pause.png";
						document.getElementById("pp").style.background = "#FF9933 !important";
						hideasidebar();
					} else {
						document.getElementById("ppbtn").src = "icons/play.png";
					}
				}, delay);
				

				// obroty wokol osi (animacja ma 40 klatek na sekundę)
				let mooncycle = 28; //28 dni to cykl ksiezyca
				let slowdown = 5;
				let onerotperframe = (Math.PI / 180) * (360/40); //360 stopni na sekunde
				let realearthrotationspeed = onerotperframe * (1000/delay);
				// let earotatespeed = 
				sun.rotation.y += 0.0003;
				mercury.rotation.y -= 0.002;	
				venus.rotation.y += 0.002;
				earth.rotation.y -= realearthrotationspeed / slowdown; //5krotne spowolnienie obrotu ziemii
				earthPivot.rotation.y += (realearthrotationspeed / slowdown) - (realearthrotationspeed / slowdown)/mooncycle;
				mars.rotation.y -= 0.002;
				jupiter.rotation.y += 0.02;

				// earthPivot.rotation.y = Math.sin(time);
				// earthPivot.rotation.x = Math.cos(time);

				}
				// END OF MOVEMENT

				// update wartosci ze slidera/ow
				rangeval.innerHTML = sizerange.value;
                renderer.render(scene, camera);
				renderer2.render(scene, camera2);

				// draworbits = true;
            };
			init();
			if (tabfocus == true) {
				animate();
			};
		</script>
	</body>
</html>