<!-- TODO
Pas asteroid +++
Reakcja na najazd mysza
Reakcja na klikniecie mysza
Dodanie pozostalych planet
Ksiezyce (ruch mozliwie najdokladniej fizycznie)
Skalowanie rozmiarow i odleglosci (na podstawie fizycznych realiów)
Reset pozycji kamery +-+
-->

<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Solar System v7 - inz</title>
		<link href="style.css" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" type="image/x-icon" href="favicon.jpg">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" 
        integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" 
        crossorigin="anonymous">
	</head>
	<body>
		<div class="settings">
			<div class="dateinfo" id="infodate"></div>
			<div class="sett">
                <div class="row">
                    <ul>
                        <li><a class="settings_button" onclick="minusyear()"><i class="fas fa-angle-double-left"></i></a></li>
                        <li><a class="settings_button" onclick="minusmonth()"><i class="fas fa-angle-left"></i></a></i></li>
                        <li><a class="settings_button" onclick="minusday()"><i class="fas fa-minus"></i></a></li>
                        <li><a class="settings_button playpause" onclick="togglepp()"><i class="fas fa-pause" id="ppbtn"></i></a></li>
                        <li><a class="settings_button" onclick="plusday()"><i class="fas fa-plus"></i></a></li>
                        <li><a class="settings_button" onclick="plusmonth()"><i class="fas fa-angle-right"></i></a></i></li>
                        <li><a class="settings_button" onclick="plusyear()"><i class="fas fa-angle-double-right"></i></a></i></li>
                    </ul>
                </div>
                <div class="row">
                    <p class="podajdate">Podaj datę:</p><input type="date" id="data" class="datepickerfield" placeholder="Wybierz Datę">
                    <a class="settings_button sd" onclick="ustawczas()">Potwierdź datę</a><br>   
                </div>
                <div class="timestatus">
                    <div class="tstat"></div>
                    <input type="checkbox" id="play" checked>
                </div>
			</div>
		</div>
		<div id="info">
			Symulator eksploracji układu słonecznego - v7
		</div>
		<div class="resetcamera">
			<a id="cameraresetbtn" 
			onclick="resetcameraposition(camToSave.position, camToSave.rotation, camToSave.controlCenter);togglecambtn()">
			RESET KAMERY
			</a>
		</div>
		<script src="three.min.js"></script>
		<script src="Orbitcontrols.js"></script>
		<script src="Projector.js"></script>
		<script src="jquery-3.3.1.min.js"></script>
		<script>
			let camreset = document.getElementById("cameraresetbtn");
			const togglecambtn = () => {
				if (camreset.style.display == "block") 
				{
					camreset.style.display = "none";
				} else camreset.style.display = "block";
			}

            let miesiace = ["stycznia","lutego","marca","kwietnia","maja","czerwca","lipca","sierpnia","września","października","listopada","grudnia"];
            let animationstate = true;
            const checktimestatus = () => {
                    if (animationstate == true) {
                    console.log("PLAY");
                } else {
                    console.log("PAUZA");
                }
            };
            let ppbtn = document.getElementById("ppbtn");
			const togglepp = () => {
				let but = document.getElementsByClassName("playpause");
				if(animationstate == true ) {
					document.getElementsByClassName("playpause").value = "Play";
					pausetime();
                    animationstate = false;
                    ppbtn.className = "fas fa-play";
				}
				else if (animationstate == false ) {
					document.getElementsByClassName("playpause").value = "Pause";
					unpausetime();
                    animationstate = true
                    ppbtn.className = "fas fa-pause";
				}
				console.log(animationstate);
			}
			const pausetime = () => {
                document.getElementById("play").checked = false;
                animationstate = false;
                ppbtn.className = "fas fa-play";
			}

			const unpausetime = () => {
                document.getElementById("play").checked = true;
                animationstate = true;
                ppbtn.className = "fas fa-pause";
			}

			// zmienne do wyliczania pozycji planet
			let mercurydata = {ink: 7.00507,an: 48.3339,ph: 77.454,md: 0.3870978,dm: 4.092353,eksorb: 0.2056324,ml: 314.42369};
			let venusdata = {ink: 3.39472,an: 76.6889,ph: 131.761,md: 0.7233238,dm: 1.602158,eksorb: 0.0067933,ml: 236.94045};
			let earthdata = {ink: 0,an: 349.2,ph: 102.8517,md: 1,dm: 0.9855796,eksorb: 0.0166967,ml: 328.40353};
			let marsdata = {ink: 1.84992,an: 49.5664,ph: 336.0882,md: 1.5236365,dm: 0.5240613,eksorb: 0.0934231,ml: 262.42784};
			let jupiterdata = {ink: 1.30463,an: 100.4713,ph: 15.6978,md: 5.202597,dm: 0.08309618,eksorb: 0.0484646,ml: 322.55983};
			let saturndata = {ink: 2.48524,an: 113.6358,ph: 88.863,md: 9.5719,dm: 0.03328656,eksorb: 0.0531651,ml: 20.95759};
			let urandata = {ink: 0.77343,an: 74.0954,ph: 175.6807,md: 19.30181,dm: 0.01162295,eksorb: 0.0428959,ml: 303.18967};
			let neptunedata = {ink: 1.7681,an: 131.7925,ph: 7.206,md: 30.26664,dm: 0.005919282,eksorb: 0.0102981,ml: 299.8641};

			// utworzenie sceny i kamery
			let scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2( 0x111111, 0.001 );
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 1, 1000 );

			// konfiguracja biblioteki OrbitControls.js
			controls = new THREE.OrbitControls( camera );
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [ 65, 83, 68 ];
			controls.addEventListener( 'change', animate );

			// wstęp do obsługi ruchy myszy
			let mouse = { x: 0, y: 0 }, INTERSECTED;
			function onMouseMove( event ) 
				{

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				}
			
			// silnik renderujący obraz
			let renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			renderer.shadowMap.enabled = true;
			renderer.setClearColor( 0x000006, 1 );

			// rozmiar ziemii
			let earthsize = 6;

			//universe
			let unigeo = new THREE.SphereGeometry(500, 50, 50);
			let unitexture = new THREE.TextureLoader().load('textures/universe.jpg');
			let unimat = new THREE.MeshBasicMaterial({color: 0x333333, map: unitexture});
			let universe = new THREE.Mesh(unigeo, unimat);
			universe.material.side = THREE.BackSide;
			scene.add(universe);

			//gwiazdy
			let stargeo = new THREE.SphereGeometry( 0.4, 9, 9);
			let starmat =  new THREE.MeshPhongMaterial( { color:0xFFFFFF, shading: THREE.FlatShading } );
			for ( let i = 0; i < 300; i ++ ) {
					let mesh = new THREE.Mesh( stargeo, starmat );
					mesh.position.x = ( Math.random() - 0.5 ) * 500;
					mesh.position.y = ( Math.random() - 0.5 ) * 500;
					mesh.position.z = ( Math.random() - 0.5 ) * 500;
					mesh.updateMatrix();
					mesh.castShadow = false;
					mesh.receiveShadow = false;
					mesh.matrixAutoUpdate = false;
					scene.add( mesh );
				}

			//slonce + swiatlo
			let sungeo = new THREE.SphereGeometry( 10, 20, 20 );
			let sun = new THREE.PointLight( 0xFFFFFF, 2, 400, 2 );
			let suntexture = new THREE.TextureLoader().load('textures/sunmap.jpg');
			let sunmaterial = new THREE.MeshBasicMaterial( { color: 0xFFFFFF, map: suntexture} );
			sun.add( new THREE.Mesh( sungeo, sunmaterial ) );
			sun.castShadow = true;
			sun.receiveShadow = false;
			scene.add( sun );
			sun.position.set(0,0,0);
	
			let ambientlight = new THREE.AmbientLight( 0xFFFFFF, 0.4 );
			scene.add(ambientlight);
		
			// merkury
			let mercgeo = new THREE.SphereGeometry(earthsize*0.38,15,15);
			let mercurytexture = new THREE.TextureLoader().load('textures/mercurymap.jpg');
			let mercurymat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: mercurytexture } );
			let mercury = new THREE.Mesh(mercgeo,mercurymat);
			mercury.receiveShadow = true;
			mercury.castShadow = true;
			scene.add(mercury);

			//venus
			let veng = new THREE.SphereGeometry(earthsize*0.95,15,15);
			let venustexture = new THREE.TextureLoader().load('textures/venusmap.jpg');
			let venusmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: venustexture } );
			let venus = new THREE.Mesh(veng,venusmat);
			venus.receiveShadow = true;
			venus.castShadow = true;
			scene.add(venus);

			//ziemia + ksiezyc
			let earthg = new THREE.SphereGeometry(earthsize,15,15);
			let earthtexture = new THREE.TextureLoader().load('textures/earthmap1k.jpg');
			let earthm = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: earthtexture } );
			// var moongeo = new THREE.SphereGeometry(1.5,5,5);
			// var moonmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF } );
			let earth = new THREE.Mesh(earthg,earthm);
			earth.receiveShadow = true;
			earth.castShadow = true;
			scene.add(earth);

			// var earthPivot = new THREE.Object3D();
			// earth.add( earthPivot );
			// var moon = new THREE.Mesh( moongeo, moonmat );
			// moon.position.x = 7;
			// moon.receiveShadow = true;
			// earthPivot.add( moon );

			// pas asteroid
			let asteroidbelt = new THREE.Object3D();
			sun.add(asteroidbelt);
			let astrogeo = new THREE.SphereGeometry (0.4, 3, 3);
			let astromat = new THREE.MeshPhongMaterial ({color: 0xffffff, shading: THREE.FlatShading} );
			for ( let i = 0; i < 700; i ++ ) {
				let mesh = new THREE.Mesh( astrogeo, astromat );
				let radius = (Math.random()-0.5)*70+220;
                let randomY = (Math.random()-0.5)*40;
				let posx = Math.cos(i)*radius;
				// if (posx <)
				mesh.position.x = (Math.cos(i))*radius;
				mesh.position.z = (Math.sin(i))*radius;
                mesh.position.y = randomY;
				// mesh.position.z = Math.sin(Math.random() - 0.5) * 100;
				mesh.updateMatrix();
				mesh.matrixAutoUpdate = false;
				asteroidbelt.add(mesh);
			}

			//mars
			let marsg = new THREE.SphereGeometry(earthsize*0.53,15,15);
			let marstexture = new THREE.TextureLoader().load('textures/marsmap.jpg');
			let marsmat = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, map: marstexture } );
			let mars = new THREE.Mesh(marsg,marsmat);
			mars.receiveShadow = true;
			mars.castShadow = true;
			scene.add(mars);
			
			let tracegeometry = new THREE.SphereGeometry(0.3, 10, 10);
			let tracematerial = new THREE.MeshBasicMaterial({color: 0xcccccc});
			// var trace = new THREE.Mesh(tracegeometry,tracematerial);

			let projector = new THREE.Projector();
			addEventListener( 'mousemove', onMouseMove, false );

			// ustwienia kamery i obsługa resetu jej pozycji
			camera.position.set(0,200,0);
			camera.lookAt (new THREE.Vector3(sun.position.x, sun.position.y, sun.position.z));
	
			let camToSave = {};
			camToSave.position = camera.position.clone();
			camToSave.rotation = camera.rotation.clone();
			camToSave.controlCenter = controls.center.clone();
			scene.rotation.x = 0.05;
			const resetcameraposition = (position, rotation, controlCenter) => {
					camera.position.set(position.x, position.y, position.z);
					camera.rotation.set(rotation.x, rotation.y, rotation.z);
					controls.center.set(controlCenter.x, controlCenter.y, controlCenter.z);
					controls.update();
					// togglecambtn();
					render();
				}
			//ustawienia kamery
				
			// sterowanie upływem czasu
			let delay = 500;
			let date = new Date();	
			window.setInterval( function() {
				if (document.hidden === false) {
					if (document.getElementById("play").checked == true) {
						date.setDate(date.getDate()+1);
					}
				}
			}, delay);
			const minusyear = () => {
				date.setFullYear(date.getFullYear()-1);
				pausetime();
				removealltrails();
			}
			const minusmonth = () => {
				date.setMonth(date.getMonth()-1);
				pausetime();
				removealltrails();
			}
			const minusday = () => {
				date.setDate(date.getDate()-1);
				pausetime();
				removealltrails();
			}
			const plusday = () => {
				date.setDate(date.getDate()+1);
				pausetime();
				removealltrails();
			}
			const plusmonth = () => {
				date.setMonth(date.getMonth()+1);
				pausetime();
				removealltrails();
			}
			const plusyear = () => {
				date.setFullYear(date.getFullYear()+1);
				pausetime();
				removealltrails();
			}
			const ustawczas = () => {
				let chdate = document.getElementById("data").value;
				let slicedate = chdate.split('-');
				date.setFullYear(slicedate[0]);
				date.setMonth(slicedate[1]-1);
				date.setDate(slicedate[2]);
				console.log(slicedate[0]+"/"+slicedate[1]+"/"+slicedate[2]);
				pausetime();
				removealltrails();
			}

			// rysowanie orbit za planetami (dla 1 planety)
			const addtrail = (x,y,z,i,planettrace) => {
				// if ($("#play").prop('checked', true)) {
				// 	planettrace[i] = new THREE.Mesh(tracegeometry,tracematerial);
				// planettrace[i].position.set(x,y,z);
				// scene.add(planettrace[i]);
				// }
				planettrace[i] = new THREE.Mesh(tracegeometry,tracematerial);
				planettrace[i].position.set(x,y,z);
				scene.add(planettrace[i]);
			}

			// usuwanie rysowanych orbit
			const removetrail = (trailarray) => {
				let max = trailarray.length;
				for (let i = 0; i <= max; i++) {
					scene.remove(trailarray[i]);
				}
				for (let i = 0; i <= max; i++) {
					trailarray.shift();
				}
			}
			const removealltrails = () => {
				removetrail(mtr);
				removetrail(vtr);
				removetrail(etr);
				removetrail(matr);
				removetrail(jtr);
				removetrail(str);
				removetrail(utr);
				removetrail(ntr);
			}

			// funkcja obliczajaca pozycje planet w czasie
			const calcplanetpos = (b2, b3, b4, b5, b6, f5, f6, f7, f8, f9, f10, f11) => {
					let f2 = 2450680.5; //cej
					let b7 = 367*b2-parseInt(7*(b2+parseInt((b3+9)/12))/4)+parseInt(275*b3/9)+b4-730531.5+(b5+(b6/60)); //j2000.0
					let b8 = b7-(f2-2451545); //el_dnia!!!!!!!!

					// zmiana orbity na radiany
					let g5 = f5*(Math.PI/180); //inkrad
					let g6 = f6*(Math.PI/180); //anrad
					let g7 = f7*(Math.PI/180); //phrad
					let g9 = f9*(Math.PI/180); //dmrad
					let g11 =  f11*(Math.PI/180); //mlrad

					//główne obliczenia
					let g13 = (g9*b8+g11-g7)%(2*Math.PI); //mean_anomally
					let g14 = g13+(2*f10-(Math.pow(f10,3)/4)+(5/96)*(Math.pow(f10,5)))*Math.sin(g13)+(5*(Math.pow(f10,2))/4-(11/24)*Math.pow(f10,4))*Math.sin(2*g13)+(13*(Math.pow(f10,3)/12))-(43/64)*Math.pow(f10,5)*Math.sin(3*g13)+(103/96)*Math.pow(f10,4)*Math.sin(4*g13)+(1097/960.0)*Math.pow(f10,5)*Math.sin(5*g13); //true anomally
					let g15 = (g14+g7)%(2*Math.PI); //longitude
					let f16 = f8*(1-Math.pow(f10,2))/(1+f10*Math.cos(g14)); //el_odl
					let c9 = Math.atan2(Math.cos(g15-g6),Math.sin(g15-g6)*Math.cos(g5))+g6; //helio_long
					let c10 = Math.asin(Math.sin(g15-g6)*Math.sin(g5)); //helio_lat

					// wspolrzedne ekliptyczne
					let b11 = f16*Math.cos(c10);
					let x = b11*Math.cos(c9)*Math.cos(c10);
					let z = b11*Math.sin(c9)*Math.cos(c10);
					let y = b11*Math.sin(c10);

					return [x , z , y]; 
				}

			// tablice dla sladow
			let loops = [0,0,0,0,0,0,0,0];
			let mtr = [];
			let vtr = [];
			let etr = [];
			let matr = [];
			let jtr = [];
			let str = [];
			let utr = [];
			let ntr = [];
			var trailsize = 100;

			let i = 0;

			var animate = function () {
				
				// czestotliwosc odswiezania symulacji
				setTimeout( function() {
			        requestAnimationFrame( animate );
			    }, 1);

			    //kontrola resizingu okna
				window.addEventListener( 'resize', onWindowResize, false );

				function onWindowResize()
				{
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					controls.handleResize();

				    renderer.setSize( window.innerWidth, window.innerHeight );
				}

				//wciągnięcie szczegółów daty
				let b2 = date.getFullYear(); //year
				let b3 = date.getMonth()+1; //month
				let b4 = date.getDate(); //day
				let b5 = date.getHours(); //hours
				let b6 = date.getMinutes(); //minutes

				// var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				// // projector.unprojectVector( vector, camera );
				// vector.unproject(camera);
				// var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

				//rotacja słońca
				// sun.rotation.x += 0.0001;
				sun.rotation.y += 0.0005;
				

				//ustawienie planet po przeliczeniu ich pozycji (co 60 klatek)
				if(++i % 30 == 0) {
                    console.log("TIK");
                    // checktimestatus();

					// pojawienie sie przycisku jesli ruszymy kamera
					if ((camera.position.x != camToSave.position.x)) {
						camreset.style.display = "block";
						// console.log("Ruszono kamera");
					} else camreset.style.display = "none";

					// merkury
					let mpos = calcplanetpos(b2, b3, b4, b5, b6, mercurydata.ink, mercurydata.an, mercurydata.ph, mercurydata.md, mercurydata.dm, mercurydata.eksorb, mercurydata.ml)
						addtrail(mercury.position.x, mercury.position.y, mercury.position.z, loops[0], mtr);
						if(mtr.length >= trailsize*0.7) {
							scene.remove(mtr[0]);
							mtr.shift();
							loops[0] = trailsize*0.7;
						}
						else loops[0]++;

						mercury.position.x = mpos[0] * 70;
						mercury.position.z = mpos[1] * 70;
						mercury.position.y = mpos[2] * 70;
						
					// venus
					let vpos = calcplanetpos(b2, b3, b4, b5, b6, venusdata.ink, venusdata.an, venusdata.ph, venusdata.md, venusdata.dm, venusdata.eksorb, venusdata.ml)
						addtrail(venus.position.x, venus.position.y, venus.position.z, loops[1], vtr);
						if(vtr.length >= trailsize*2) {
							scene.remove(vtr[0]);
							vtr.shift();
							loops[1] = trailsize*2;
						}
						else loops[1]++;

						venus.position.x = vpos[0] * 70;
						venus.position.z = vpos[1] * 70;
						venus.position.y = vpos[2] * 70;
						
					// ziemia
					let epos = calcplanetpos(b2, b3, b4, b5, b6, earthdata.ink, earthdata.an, earthdata.ph, earthdata.md, earthdata.dm, earthdata.eksorb, earthdata.ml);
						addtrail(earth.position.x, earth.position.y, earth.position.z, loops[2], etr);
						if(etr.length >= trailsize*3) {
							scene.remove(etr[0]);
							etr.shift();
							loops[2] = trailsize*3;
						}
						else loops[2]++;
						// addtrail(earth.position.x, earth.position.y, earth.position.z);
						earth.position.x = epos[0] * 70;
						earth.position.z = epos[1] * 70;
						earth.position.y = epos[2] * 70;
						

					var marspos = calcplanetpos(b2, b3, b4, b5, b6, marsdata.ink, marsdata.an, marsdata.ph, marsdata.md, marsdata.dm, marsdata.eksorb, marsdata.ml);
					// addtrail(mars.position.x, mars.position.y, mars.position.z);
						mars.position.x = marspos[0] * 70;
						mars.position.z = marspos[1] * 70;
						mars.position.y = marspos[2] * 70;
						

						
				}	
				if(i > 1200) { i = 0 };

				// obroty wokol osi
				mercury.rotation.y -= 0.002;	
				venus.rotation.y -= 0.002;
				earth.rotation.y -= 360/1000/16/2;	
				mars.rotation.y -= 0.002;

				// earthPivot.rotation.y = Math.sin(time);
				// earthPivot.rotation.x = Math.cos(time);
				

				var strdate = b4+" " +miesiace[b3-1]+" "+b2+" r";

                renderer.render(scene, camera);
                
				$(".dateinfo").html("Data: "+strdate);

            };
            let TAB = "\t";
			animate();
		</script>
	</body>
</html>